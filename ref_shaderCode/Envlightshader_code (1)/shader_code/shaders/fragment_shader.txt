#version 300 es
precision highp float; 
precision highp int;
out vec4 outColor;

#define PI 3.1415926535897932384626433832795

in vec2 tc; // texture coordinate of pixel (interpolated)
in vec3 wfn; // fragment normal of pixel (interpolated)
in vec3 vertPos; // fragment vertex position (interpolated)
uniform sampler2D envMapImage; // min_filter="LINEAR_MIPMAP_NEAREST" mag_filter="LINEAR"
uniform sampler2D prefilteredEnvmap; // min_filter="LINEAR_MIPMAP_LINEAR" mag_filter="LINEAR" 
uniform sampler2D brdfIntegrationMap; 
uniform sampler2D diffuseMap; // min_filter="LINEAR" mag_filter="LINEAR"
uniform vec4 baseColor;  // description="albedo for dielectrics or specular color for metals" defaultval ="1.0, 0.9, 0.62, 1.0"

uniform sampler2D baseColorTexture; // wrap_s="REPEAT" wrap_t="REPEAT"
uniform float texScale;  // description="scaling factor of the texture coordinates" defaultval="2.0"

uniform float roughness; // description="roughness in range [0.0, 1.0]" defaultval ="0.2"
uniform float metallic; // description="metallic parameter, 0.0 for dielectrics, 1.0 for metals" defaultval ="1.0"
uniform float reflectance; // description="Fresnel reflectance for non-metallic materials in range [0.0, 1.0]" defaultval ="0.5"
uniform bool showBackground; // defaultval="true"
uniform vec3 cameraPos; // description="camera position in global coordinate system"
uniform int mipCount; // description="number of usable mipmap levels in the prefilteredEnvmap" defaultval ="5"
uniform int gsnMeshGroup;
uniform bool checkMR;
uniform bool checkBasecolor;
uniform bool checkNorm;

vec2 directionToSphericalEnvmap(vec3 dir) {
  float s = 1.0 - mod(1.0 / (2.0*PI) * atan(dir.y, dir.x), 1.0);
  float t = 1.0 / (PI) * acos(-dir.z);
  return vec2(s, t);
}

// adapted from "Real Shading in Unreal Engine 4", Brian Karis, Epic Games
// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
vec3 specularIBL(vec3 F0 , float roughness, vec3 N, vec3 V) {
  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = reflect(-V, N);
  vec2 uv = directionToSphericalEnvmap(R);
  vec3 prefilteredColor = textureLod(prefilteredEnvmap, uv, roughness*float(mipCount)).rgb;
  vec4 brdfIntegration = texture(brdfIntegrationMap, vec2(NoV, roughness));
  return prefilteredColor * ( F0 * brdfIntegration.x + brdfIntegration.y );
}

vec3 diffuseIBL(vec3 normal) {
  vec2 uv = directionToSphericalEnvmap(normal);
  return texture(diffuseMap, uv).rgb;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
} 

void main() {
  vec3 normal = normalize(wfn);
  vec3 viewDir = normalize(cameraPos - vertPos);
  
  if(gsnMeshGroup == 0) { // render envmap
    if(showBackground) {
      // color of envmap sphere
      outColor.rgb = texture(envMapImage, vec2(1.0-tc.x, tc.y)).rgb;
      outColor.a = 1.0;
    } else {
      discard;
    }
  } else {
    // render 3D mesh
    
    // vec3 baseCol = pow(baseColor.rgb, vec3(2.2));
    vec3 baseCol = pow(texture(baseColorTexture, texScale*tc).rgb, vec3(2.2)); //~~~
    
    // F0 for dielectics in range [0.0, 0.16] 
    // default FO is (0.16 * 0.5^2) = 0.04
    vec3 f0 = vec3(0.16 * (reflectance * reflectance)); 
    // in case of metals, baseColor contains F0
    f0 = mix(f0, baseCol, metallic);
    
    // compute diffuse and specular factors
    vec3 F = fresnelSchlick(max(dot(normal, viewDir), 0.0), f0);
    vec3 kS = F;
    vec3 kD = 1.0 - kS;
    kD *= 1.0 - metallic;    
    
    vec3 specular = specularIBL(f0, roughness, normal, viewDir); 
    vec3 diffuse = diffuseIBL(normal);
    
    // shading front-facing
    vec3 color = pow(kD * baseCol * diffuse + specular, vec3(1.0/2.2));
    
    // shading back-facing
    if(dot(viewDir, normal) < -0.1) {
      //discard;
      color = 0.1 * baseCol * diffuse;
    }
    
    if(checkBasecolor) {
      color = baseCol;
    }
    
    if(checkMR) {
      color.r = metallic;
      color.g = roughness;
      color.b = 0.0;
    }
    
    if(checkNorm){
      color = normal;
    }
    
    outColor.rgb = color;
    outColor.a = 1.0;
  }
}
