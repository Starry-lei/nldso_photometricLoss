

show new R12:
   0.985971  -0.0206748    0.165574
  0.0192452    0.999642    0.010485
   -0.16578 -0.00715934    0.986018



 Show optimized rotation:
 0.944808 0.0197068 -0.327352
0.0320588  0.987838  0.152298
 0.326374 -0.154383  0.932685
 Show optimized translation:
  1.04102
-0.484238
0.0806567


#version 300 es
precision highp float;
precision highp int;
out vec4 outColor;

#define PI 3.1415926535897932384626433832795

in vec2 tc; // texture coordinate of pixel (interpolated)
in vec3 wfn; // fragment normal of pixel (interpolated)
in vec3 vertPos; // fragment vertex position (interpolated)
uniform sampler2D envMapImage; // min_filter="LINEAR_MIPMAP_NEAREST" mag_filter="LINEAR"
uniform sampler2D prefilteredEnvmap; // min_filter="LINEAR_MIPMAP_LINEAR" mag_filter="LINEAR"
uniform sampler2D brdfIntegrationMap;
uniform sampler2D diffuseMap; // min_filter="LINEAR" mag_filter="LINEAR"
uniform vec4 baseColor;  // description="albedo for dielectrics or specular color for metals" defaultval ="1.0, 0.9, 0.62, 1.0"

uniform sampler2D baseColorTexture; // wrap_s="REPEAT" wrap_t="REPEAT"
uniform float texScale;  // description="scaling factor of the texture coordinates" defaultval="2.0"

uniform float roughness; // description="roughness in range [0.0, 1.0]" defaultval ="0.2"
uniform float metallic; // description="metallic parameter, 0.0 for dielectrics, 1.0 for metals" defaultval ="1.0"
uniform float reflectance; // description="Fresnel reflectance for non-metallic materials in range [0.0, 1.0]" defaultval ="0.5"
uniform bool showBackground; // defaultval="true"
uniform vec3 cameraPos; // description="camera position in global coordinate system"
uniform int mipCount; // description="number of usable mipmap levels in the prefilteredEnvmap" defaultval ="5"
uniform int gsnMeshGroup;
uniform bool checkMR;
uniform bool checkBasecolor;
uniform bool checkNorm;

 vec3 CheckTexLod;
 vec4 brdfIntegration_check;
 vec4 diffuse_check;
uniform bool showCheckTexLod;
uniform bool showCheckTexBrdf;
uniform bool showCheckTexDiffuse;



vec2 directionToSphericalEnvmap(vec3 dir) {
  float s = 1.0 - mod(1.0 / (2.0*PI) * atan(dir.y, dir.x), 1.0);
  float t = 1.0 / (PI) * acos(-dir.z);
  return vec2(s, t);
}

// adapted from "Real Shading in Unreal Engine 4", Brian Karis, Epic Games
// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf


vec3 specularIBL(vec3 F0 , float roughness, vec3 N, vec3 V) {

  float NoV = clamp(dot(N, V), 0.0, 1.0);
  vec3 R = reflect(-V, N);
  vec2 uv = directionToSphericalEnvmap(R);

  vec3 prefilteredColor = textureLod(prefilteredEnvmap, uv, roughness*float(mipCount)).rgb;
  vec4 brdfIntegration = texture(brdfIntegrationMap, vec2(NoV, roughness));

  return prefilteredColor * ( F0 * brdfIntegration.x + brdfIntegration.y );



}











vec3 diffuseIBL(vec3 normal) {

  vec2 uv = directionToSphericalEnvmap(normal);
  // added by lei
    vec2 uv_test_diffuse=vec2(0.5f, 0.5f);
  diffuse_check = texture(diffuseMap, uv_test_diffuse);
  return texture(diffuseMap, uv).rgb;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

void main() {
  vec3 normal = normalize(wfn);
  vec3 viewDir = normalize(cameraPos - vertPos);

  if(gsnMeshGroup == 0) { // render envmap
    if(showBackground) {
      // color of envmap sphere
      outColor.rgb = texture(envMapImage, vec2(1.0-tc.x, tc.y)).rgb;
      outColor.a = 1.0;
    } else {
      discard;
    }
  } else {
    // render 3D mesh



                // vec3 baseCol = pow(baseColor.rgb, vec3(2.2));

    vec3 baseCol = pow(texture(baseColorTexture, texScale*tc).rgb, vec3(2.2)); //~~~

                // F0 for dielectics in range [0.0, 0.16]
                // default FO is (0.16 * 0.5^2) = 0.04
    vec3 f0 = vec3(0.16 * (reflectance * reflectance));
                // in case of metals, baseColor contains F0
    f0 = mix(f0, baseCol, metallic);
                // compute diffuse and specular factors
    vec3 F = fresnelSchlick(max(dot(normal, viewDir), 0.0), f0);
    vec3 kS = F;
    vec3 kD = 1.0 - kS;
    kD *= 1.0 - metallic;
    vec3 specular = specularIBL(f0, roughness, normal, viewDir);

    vec3 diffuse = diffuseIBL(normal);
                 // shading front-facing
    vec3 color = pow(kD * baseCol * diffuse + specular, vec3(1.0/2.2));



    // shading back-facing
    if(dot(viewDir, normal) < -0.1) {
      //discard;
      color = 0.1 * baseCol * diffuse;
    }


    if(checkBasecolor) {
      color = baseCol;
    }
    if(checkMR) {
      color.r = metallic;
      color.g = roughness;
      color.b = 0.0;
    }
    if(checkNorm){
      color = normal;
    }
    if(showCheckTexLod){
     color.r = CheckTexLod.r;
      color.g =CheckTexLod.g;
      color.b =CheckTexLod.b;
    }
    if(showCheckTexBrdf){
      color.r = brdfIntegration_check.x;
      color.g = brdfIntegration_check.y;
      color.b = 0.0;
    }
    if(showCheckTexDiffuse){
      color.r = diffuse_check.r;
      color.g = diffuse_check.g;
      color.b =diffuse_check.b ;
    }


    outColor.rgb = color;
    outColor.a = 1.0;
  }
}



  template <typename T> int sign(T val) {
      return (T(0) < val) - (val < T(0));
    }

    float atan2_r( float y,  float x)
    {
      return x == 0.0 ? sign(y)*M_PI/2 : std::atan2(y, x);
    }

